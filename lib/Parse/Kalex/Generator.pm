#! /bin/false

# Copyright (C) 2018 Guido Flohr <guido.flohr@cantanea.com>,
# all rights reserved.

# This program is free software. It comes without any warranty, to
# the extent permitted by applicable law. You can redistribute it
# and/or modify it under the terms of the Do What the Fuck You Want
# to Public License, Version 2, as published by Sam Hocevar. See
# http://www.wtfpl.net/ for more details.

package Parse::Kalex::Generator;

use strict;

sub new {
    my ($class, $lexer) = @_;

    bless {
        __top => [],
        __lexer => $lexer,
        __filename => '',
    }, $class;
}

sub addTop {
    my ($self, $code) = @_;

    my @location = $self->{__lexer}->yylocation;
    push @{$self->{__top}}, [ $code, @location ];

    return $self;
}

sub generate {
    my ($self, %options) = @_;

    # FIXME! Merge in options from scanner definition.

    my $output = $self->__topCode;

    if (defined $options{package}) {
        $output .= <<EOF;
#! /bin/false

# A lexical scanner generated by kalex.

package $options{package};

EOF
    } else {
        $output .= <<EOF;
#! /usr/bin/env perl

# A lexical scanner generated by kalex.

EOF

        $output .= $self->__readModuleCode('Parse/Kalex/Snippets/main.pm');

        $output .= "package Parse::Kalex::Lexer;\n";
    }

    # FIXME! Insert top-section.

    $output .= $self->__readModuleCode('Parse/Kalex/Snippets/Base.pm');

    if (!defined $options{package}) {
        $output .= "package main;\n\nno strict;\n\n";
    }

    return $output;
}

sub __topCode {
    my ($self) = @_;

    my $output = '';

    foreach (@{$self->{__top}}) {
        my ($snippet, @location) = @$_;

        chomp $snippet;
        $snippet .= "\n";
        $output .= $self->__addLocation($snippet, @location);
        $output .= "$snippet\n";
    }

    return $output;
}

sub __addLocation {
    my ($self, $snippet, $filename, $lineno) = @_;

    my $location = '';
    if ($filename ne $self->{__filename} || $lineno != $self->{__lineno}) {
        $location = qq{#line $lineno "$filename"\n};
    } 
    $self->{__filename} = $filename;
    $self->{__lineno} = $lineno + ($snippet =~ y/\n/\n/);

    return $location;
}

sub __readModuleCode {
    my ($self, $module) = @_;

    my $code = '';
    eval {
        my $filename;
        foreach my $path (@INC) {
            $filename = File::Spec->catfile($path, $module);
            last if -e $filename;
        }
        die __x("cannot locate '{module}' in \@INC.  (\@INC contains: {INC}).",
                module => $module, INC => join ' ', @INC)
            if !-e $filename;

        open my $fh, '<', $filename
            or die __x("error opening '{filename}' for"
                       . " reading: {error}!",
                       filename => $filename, error => $!);
        while (defined(my $line = $fh->getline)) {
            last if $line =~ /^package/;
        }
        while (defined(my $line = $fh->getline)) {
            last if $line =~ /^1;/;
            $code .= $line;
        }

        if (!length $code) {
            die __x("could not find any code in module '{module}''",
                    module => $module);
        }
    };
    if ($@) {
        $self->__yyfatal(__x("error reading code from mode '{module}': {err}",
                             module => $module, err => $@));
    }

    return $code;
}

1;
