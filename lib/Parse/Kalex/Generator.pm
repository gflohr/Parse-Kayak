#! /bin/false

# Copyright (C) 2018 Guido Flohr <guido.flohr@cantanea.com>,
# all rights reserved.

# This program is free software. It comes without any warranty, to
# the extent permitted by applicable law. You can redistribute it
# and/or modify it under the terms of the Do What the Fuck You Want
# to Public License, Version 2, as published by Sam Hocevar. See
# http://www.wtfpl.net/ for more details.

package Parse::Kalex::Generator;

use strict;

use Locale::TextDomain qw(kayak);

sub new {
    my ($class, $lexer) = @_;

    bless {
        __errors => 0,
        __top_code => [],
        __def_code => [],
        __lexer => $lexer,
        __filename => '',
        __start_conditions => {
            INITIAL => 1,
        },
        __xstart_condtions => {},
        __rules => [],
    }, $class;
}

sub addTopCode {
    my ($self, $code) = @_;

    my @location = $self->{__lexer}->yylocation;
    push @{$self->{__top_code}}, [ $code, @location ];

    return $self;
}

sub addDefCode {
    my ($self, $code) = @_;

    my @location = $self->{__lexer}->yylocation;
    push @{$self->{__def_code}}, [ $code, @location ];

    return $self;
}

sub setUserCode {
    my ($self, $code) = @_;

    my @location = $self->{__lexer}->yylocation;
    $self->{__user_code} = [$code, @location ];

    return $self;
}

sub addStartConditions {
    my ($self, $type, $conditions) = @_;

    if ($type eq '%x') {
        foreach my $condition (@$conditions) {
            $self->{__xstart_conditions}->{$condition} = 1;
        }
    } else {
        foreach my $condition (@$conditions) {
            $self->{__start_conditions}->{$condition} = 1;
        }
    }

    return $self;
}

sub checkStartConditionDeclaration {
    my ($self, $condition, $exclusive) = @_;

    if (!exists $self->{__start_conditions}->{$condition}
        || exists $self->{__xstart_conditions}->{$condition}) {
        my $location = $self->{__lexer}->yylocation;
        warn __x("{location}: warning: start condition '{condition}'"
                 . " is already declared.\n",
                 location => $location, condition => $condition);
    }

    return $self;
}

sub checkStartCondition {
    my ($self, $condition) = @_;

    if (!exists $self->{__start_conditions}->{$condition}
        && !exists $self->{__xstart_conditions}->{$condition}) {
        my $location = $self->{__lexer}->yylocation;
        warn __x("{location}: warning: undeclared start condition '{condition}'.\n",
                 location => $location, condition => $condition);
        $self->{__start_conditions}->{$condition} = 1;
    }

    return $self;
}

sub addRule {
    my ($self, $start_conditions, $regex, $code) = @_;

    my @regex = @$regex;
    my $qr = eval { qr{^$regex[0]} };
    if ($@) {
        my $x = $@;
        my $file = quotemeta __FILE__;
        $x =~ s{ at $file line [0-9]+\.\n$}{};

        my $location = join ':', @regex[1 .. 3];
        warn __x("{location}: error: {error}.\n",
                 location => $location, error => $x);
        ++$self->{__errors};    
    } elsif ('' =~ {$qr}) {
        my $location = join ':', @regex[1 .. 3];
        warn __x("{location}: error: regular expression matches empty string.\n",
                 location => $location);
        ++$self->{__errors};                
    } else {
        push @{$self->{__rules}}, [[@$start_conditions], $qr, $code];
    }

    return $self;
}

sub errors {
    my ($self) = @_;

    return if !$self->{__errors};

    return $self->{__errors};
}

sub generate {
    my ($self, %options) = @_;

    # FIXME! Merge in options from scanner definition.

    my $output = '';
    my $top_code = $self->__topCode;

    if (defined $options{package}) {
        $output .= <<EOF;
#! /bin/false

# A lexical scanner generated by kalex.

${top_code}package $options{package};

EOF
    } else {
        $output .= <<EOF;
#! /usr/bin/env perl

# A lexical scanner generated by kalex.

${top_code}
EOF

        $output .= $self->__readModuleCode('Parse/Kalex/Snippets/main.pm');

        $output .= "package Parse::Kalex::Lexer;\n";
    }

    $output .= $self->__defCode;

    $output .= $self->__readModuleCode('Parse/Kalex/Snippets/Base.pm');

    if (!defined $options{package}) {
        $output .= "package main;\n\nno strict;\n\n";
    }

    $output .= $self->__userCode;

    return $output;
}

sub __topCode {
    my ($self) = @_;

    my $output = '';

    foreach (@{$self->{__top_code}}) {
        my ($snippet, @location) = @$_;

        chomp $snippet;
        $snippet .= "\n";
        $output .= $self->__addLocation($snippet, @location);
        $output .= $snippet;
    }

    return $output;
}

sub __defCode {
    my ($self) = @_;

    my $output = '';

    foreach (@{$self->{__def_code}}) {
        my ($snippet, @location) = @$_;

        chomp $snippet;
        $snippet .= "\n";
        $output .= $self->__addLocation($snippet, @location);
        $output .= $snippet;
    }

    return $output;
}

sub __userCode {
    my ($self) = @_;

    return '' if !defined $self->{__user_code};

    my ($snippet, @location) = @{$self->{__user_code}};
    chomp $snippet;
    $snippet .= "\n";

    my $output = $self->__addLocation($snippet, @location);
    $output .= $snippet;

    return $output;
}

sub __addLocation {
    my ($self, $snippet, $filename, $lineno) = @_;

    my $location = '';
    if ($filename ne $self->{__filename} || $lineno != $self->{__lineno}) {
        $location = qq{#line $lineno "$filename"\n};
    } 
    $self->{__filename} = $filename;
    $self->{__lineno} = $lineno + ($snippet =~ y/\n/\n/);

    return $location;
}

sub __readModuleCode {
    my ($self, $module) = @_;

    my $code = '';
    eval {
        my $filename;
        foreach my $path (@INC) {
            $filename = File::Spec->catfile($path, $module);
            last if -e $filename;
        }
        die __x("cannot locate '{module}' in \@INC.  (\@INC contains: {INC}).",
                module => $module, INC => join ' ', @INC)
            if !-e $filename;

        open my $fh, '<', $filename
            or die __x("error opening '{filename}' for"
                       . " reading: {error}!",
                       filename => $filename, error => $!);
        while (defined(my $line = $fh->getline)) {
            last if $line =~ /^package/;
        }
        while (defined(my $line = $fh->getline)) {
            last if $line =~ /^1;/;
            $code .= $line;
        }

        if (!length $code) {
            die __x("could not find any code in module '{module}''",
                    module => $module);
        }
    };
    if ($@) {
        die __x("error reading code from mode '{module}': {err}",
                module => $module, err => $@);
    }

    return $code;
}

1;
